.. _introduction:

Introduction to Project ACRN
############################

The open source project ACRN defines a device hypervisor reference stack
and an architecture for running multiple software subsystems, managed
securely, on a consolidated system by means of a virtual machine
manager. It also defines a reference framework implementation for
virtual device emulation, called the "ACRN Device Model".

The ACRN Hypervisor is a Type 1 reference hypervisor stack, running
directly on the bare-metal hardware, and is suitable for a variety of
IoT and embedded device solutions. The ACRN hypervisor addresses the gap
that currently exists between datacenter hypervisors, and hard
partitioning hypervisors. The ACRN hypervisor architecture partitions
the system into different functional domains, with carefully selected
guest OS sharing optimiztionsfor IoT and embedded devices.

An interesting use case example for the ACRN Hypervisor is in automotive
scenario.  The ACRN hypervisor can be used for building a Software
Defined Cockpit (SDC) or an In-Vehicle Experience (IVE) solution.  As a
reference implementation, ACRN provides the basis for embedded
hypervisor vendors to build solutions with a reference I/O mediation
solution.

In this scenario, an automotive SDC system consists of the Instrument
Cluster (IC) system, the In-Vehicle Infotainment (IVI) system, and one
or more Rear Seat Entertainment (RSE) systems. Each system is running as
an isolated Virtual Machine (VM) for overall system safety
considerations.

An **Instrument Cluster (IC)** system is used to show the driver operational
information about the vehicle, such as:

-  the speed, the fuel level, trip mile and other driving information of
   the car;
-  projecting heads-up images on the windshield, with alerts for low
   fuel or tire pressure;
-  showing rear-view camera, and surround-view for parking assistance.

An **In-Vehicle Infotainment (IVI)** system's capabilities can include:

-  navigation systems, radios, and other entertainment systems;
-  connection to mobile devices for phone calls, music, and applications
   via voice recognition;
-  control interaction by gesture recognition or touch.

A **Rear Seat Entertainment (RSE)** system could run:

-  entertainment system;
-  virtual office;
-  connection to the front-seat IVI system and mobile devices (cloud
   connectivity).
-  connection to mobile devices for phone calls, music, and
   applications via voice recognition;
-  control interaction by gesture recognition or touch

The ACRN hypervisor can support both Linux\* VM and Android\* VM as a
User OS, with the User OS managed by the ACRN hypervisor. Developers and
OEMs can use this reference stack to run their own VMs, together with
IC, IVI, and RSE VMs. The Service OS runs as VM0 (also known as Dom0 in
other hypervisors) and the User OS runs as VM1, (also known as DomU).

:numref:`ivi-block` shows an example block diagram of using the ACRN
hypervisor.

.. figure:: images/IVI-block.png
   :align: center
   :name: ivi-block

   Service OS and User OS on top of ACRN hypervisor

This ACRN hypervisor block diagram shows:

-  The ACRN hypervisor sits right on top of the bootloader for fast
   booting capabilities.
-  Partitioning of resources to ensure safety-critical and non-safety
   critical domains are able to coexist on one platform.
-  Rich I/O mediators allows various I/O devices shared across VMs, and
   thus delivers a comprehensive user experience
-  Multiple operating systems are supported by one SoC through efficient
   virtualization.

.. note::
   The yellow color parts in :numref:`ivi-block` are part of the project
   ACRN software stack. This is a reference architecture diagram and not
   all features mentioned are fully functional. Other blocks will come from
   other (open source) projects and are listed here for reference only.

   For example: the Service OS and Linux Guest can come from the Clear
   Linux project at https://clearlinux.org and (in later updates) the
   Android as a Guest support can come from https://01.org/android-ia.

   For the current ACRN-supported feature list, please see
   :ref:`release_notes`.

Licensing
*********
.. _BSD-3-Clause: https://opensource.org/licenses/BSD-3-Clause

Both the ACRN hypervisor and ACRN Device model software are provided
under the permissive `BSD-3-Clause`_ license, which allows
*"redistribution and use in source and binary forms, with or without
modification"* together with the intact copyright notice and
disclaimers noted in the license.

Terminology
***********

.. list-table:: Terminology
   :widths: auto
   :header-rows: 1

   * - Term
     - Description
   * - ACPI
     - Advanced Configuration and Power Interface
   * - BIOS
     - Basic Input/Output System


+-----------------------------------+-----------------------------------+
| Term                              | Description                       |
+-----------------------------------+-----------------------------------+
| ACPI                              | Advanced Configuration and Power  |
|                                   | Interface                         |
+-----------------------------------+-----------------------------------+
| BIOS                              | Basic Input/Output System.        |
+-----------------------------------+-----------------------------------+
| GPU                               | Graphics Processing Unit          |
+-----------------------------------+-----------------------------------+
| I2C                               | Inter-Integrated Circuit          |
+-----------------------------------+-----------------------------------+
| IC                                | Instrument Cluster                |
+-----------------------------------+-----------------------------------+
| IVE                               | In-Vehicle Experience             |
+-----------------------------------+-----------------------------------+
| IVI                               | In-vehicle Infotainment           |
+-----------------------------------+-----------------------------------+
| OS                                | Operating System                  |
+-----------------------------------+-----------------------------------+
| OSPM                              | Operating System Power Management |
+-----------------------------------+-----------------------------------+
| PCI                               | Peripheral Component Interface.   |
+-----------------------------------+-----------------------------------+
| PM                                | Power Management                  |
+-----------------------------------+-----------------------------------+
| Pass-Through Devices              | Physical devices (typically PCI)  |
|                                   | exclusively assigned to a guest.  |
|                                   |  In this architecture,            |
|                                   | pass-through devices are owned by |
|                                   | the foreground OS.                |
+-----------------------------------+-----------------------------------+
| PV                                | Para-virtualization -\ `https://e |
|                                   | n.wikipedia.org/wiki/Paravirtuali |
|                                   | zation <https://www.google.com/ur |
|                                   | l?q=https://en.wikipedia.org/wiki |
|                                   | /Paravirtualization&sa=D&ust=1520 |
|                                   | 533207654000&usg=AFQjCNHzUPHU6bvK |
|                                   | YF5ZDSDknq9sgUtM9g>`__            |
+-----------------------------------+-----------------------------------+
| RSE                               | Rear                              |
|                                   |                                   |
|                                   | Seat Entertainment                |
+-----------------------------------+-----------------------------------+
| SDC                               | Software Defined Cockpit          |
+-----------------------------------+-----------------------------------+
| SOS                               | Service OS                        |
+-----------------------------------+-----------------------------------+
| UEFI                              |                                   |
+-----------------------------------+-----------------------------------+
| UOS                               | User OS                           |
+-----------------------------------+-----------------------------------+
| VHM                               | Virtio and Hypervisor Service     |
|                                   | Module                            |
+-----------------------------------+-----------------------------------+
| VM                                | Virtual Machine                   |
+-----------------------------------+-----------------------------------+
| VMM                               | Virtual Machine Monitor           |
+-----------------------------------+-----------------------------------+
| VMX                               | Virtual Machine Extension         |
+-----------------------------------+-----------------------------------+
| Virtio-BE                         | Back-End, VirtIO framework        |
|                                   | provides front-end driver and     |
|                                   | back-end driver for IO mediators, |
|                                   | developer has habit of using      |
|                                   | Shorthand. So they say Virtio-BE  |
|                                   | and Virtio-FE                     |
+-----------------------------------+-----------------------------------+
| Virtio-FE                         | Front-End, VirtIO framework       |
|                                   | provides front-end driver and     |
|                                   | back-end driver for IO mediators, |
|                                   | developer has  habit of using     |
|                                   | Shorthand. So they say Virtio-BE  |
|                                   | and Virtio-FE                     |
+-----------------------------------+-----------------------------------+
| VT                                | Intel Virtualization Technology   |
+-----------------------------------+-----------------------------------+
| VT-d                              | Virtualization Technology for     |
|                                   | Directed I/O                      |
+-----------------------------------+-----------------------------------+

.. _h.gbjy1p4qbcf8:

2.3 Overview (overview for what??)
----------------------------------

.. _h.dnoapo3mv5wn:

2.3.1 ACRN Device Model, Service OS, and User OS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To keep the hypervisor code base as small and efficient as possible, the
bulk of the device model implementation resides in the Service OS to
provide  sharing and other capabilities. The details of which devices
are shared and the mechanism used for their sharing is described in
section 2.3.5.

The Service OS runs with the system’s highest virtual machine priority
to ensure required device time-sensitive requirements and system quality
of service (QoS). Service OS tasks run with mixed priority. Upon a
callback servicing a particular User OS request, the corresponding
software (or mediator) in the Service OS inherits the User OS priority.
There may also be additional low-priority background tasks within the
Service OS.  

In the automotive example, the User OS is the central hub of vehicle
control and in-vehicle entertainment. It provides support for radio and
entertainment options, control of the vehicle climate control, and
vehicle navigation displays. It also provides connectivity using USB,
Bluetooth, and/or WiFi for third-party device interaction with the
vehicle, such as Android Auto\* or Apple CarPlay*, and many other
features.

.. _h.yfxp9sdoci8m:

2.3.2 Boot Sequence 
~~~~~~~~~~~~~~~~~~~~

Here we are using a verified Boot Sequence with UEFI as a sample on
Intel® Architecture platform \ `NUC Kit
NUC6CAYH <https://www.google.com/url?q=https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc6cayh.html&sa=D&ust=1520533207663000&usg=AFQjCNEUngM1uACF16FYb9gUWZdsChNNEw>`__\ (\ `Intel®
Celeron® Processor
J3455 <https://www.google.com/url?q=https://ark.intel.com/products/95594/Intel-Celeron-Processor-J3455-2M-Cache-up-to-2_3-GHz&sa=D&ust=1520533207663000&usg=AFQjCNERO4z2otTBTbaarufAfSrRlnnISw>`__\ )
 - Figure 2.

|image1|

Figure 2 ACRN Hypervisor Boot Flow

Boot process as below:

•UEFI verifies and boots ACRN hypervisor & Service OS Bootloader 
(???Change the picture to SOS Bootloader???)

•UEFI (or Service OS Bootloader) verifies and boots Service OS kernel

•Service OS kernel verifies and loads ACRN Device Model and Virtual
bootloader through dm-verity

•Virtual bootloader starts the User side verified boot process

 (??? Shoudl we add a box of “UOS Kernel” in Figure 2???”)

In the ACRN project, the github provides ACRN hypervisor and ACRN Device
model only, however, you should have below list ready to run a complete
validation or development on \ `NUC Kit
NUC6CAYH <https://www.google.com/url?q=https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc6cayh.html&sa=D&ust=1520533207665000&usg=AFQjCNEyVFNuwdVUfDTlu2S1xzKSHrK0Bw>`__\ :

1, User may need install or update latest UEFI firmware for the
hardware, UEFI firmware for the \ `NUC Kit
NUC6CAYH <https://www.google.com/url?q=https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc6cayh.html&sa=D&ust=1520533207666000&usg=AFQjCNFIYKgJZ9lWrzJyvU3jwGRNI1Qbiw>`__\  need
to download and install \ `latest BIOS
version <https://www.google.com/url?q=https://downloadcenter.intel.com/search?keyword%3Dnuc6cayh%2Bbios&sa=D&ust=1520533207666000&usg=AFQjCNHBb9eGthjVgug-SdlkBIkmuBnimQ>`__\ .
(learn how to \ `update
BIOS <https://www.google.com/url?q=https://www.intel.com/content/www/us/en/support/articles/000005636.html&sa=D&ust=1520533207666000&usg=AFQjCNE2p9KF8scsWRkzFxtAqbxocNQ7gA>`__\  )

2, Refer to
\ `https://github.com/clearlinux <https://www.google.com/url?q=https://github.com/clearlinux&sa=D&ust=1520533207667000&usg=AFQjCNE4s78QghAzka7A5cOfpCr_EKNxmA>`__\  to
get Service OS and User OS reference implement for ACRN project.

.. _h.nl4odhj4pa54:

2.3.3 ACRN  Hypervisor Architecture 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ACRN hypervisor is a Type 1 hypervisor, running directly on bare-metal
hardware. It implements a hybrid VMM architecture, using a privileged
service VM, running the Service OS that manages the I/O devices and
provides I/O mediation. Multiple User VMs are supported, with each of
them running Linux\* or Android\* OS as the User OS .

For an automotive user case. by running the IC system in a separate VM,
it can be well isolated from other VMs and their applications, and
therefore reduce the attack surface and minimize safety interference.
However, running the IC system in a separate VM may introduces
additional latency for the IC applications.

 

Figure 3 shows the ACRN hypervisor architecture, with the IC VM and
service VM together. The Service OS (SOS) owns most of the devices
including the platform devices, and provides I/O mediation. Some of the
PCIe devices may be passed through to the User OSes via the VM
configuration. The SOS runs the IC applications and hypervisor-specific
applications together, such as the ACRN device model, and ACRN VM
manager.

ACRN hypervisor also runs the ACRN VM manager to collect the running
information of the User OS, and controls the User VM such as starting,
stopping, and pausing a VM, pausing or resuming a virtual CPU, etc.

|image2|

Figure 3 ACRN Hypervisor Architecture

ACRN hypervisor takes advantage of Intel Virtualization Technology
(Intel VT), and ACRN hypervisor runs in Virtual Machine Extension (VMX)
root operation, or host mode, or VMM mode.  All the guests, including
UOS and SOS, run in VMX non-root operation, or guest mode. (Hereafter,
we use the terms VMM mode and Guest mode for simplicity).

The VMM mode has 4 protection rings, but it runs the ACRN hypervisor in
ring 0 privilege only, and leaves rings 1-3 unused. The guest (including
SOS & UOS), running in Guest mode, also has its own four protection
rings (ring 0 to 3). The User kernel runs in ring 0 of guest mode, and
user land applications run in ring 3 of User mode (ring 1 & 2 are
usually not used by commercial OSes).                                  
                                                   

 \ |image3|\         

Figure 4 VMX Brief

VMM mode and guest mode are switched through VM Exit and VM Entry. When
the bootloader hands off control to the ACRN hypervisor, the processor
hasn’t enabled VMX operation yet. The ACRN hypervisor needs to enable
VMX operation thru a VMXON instruction first. Initially, the processor
stays in VMM mode when the VMX operation is enabled. It enters guest
mode thru a VM resume instruction (or first time VM launch), and returns
back to VMM mode thru a VM exit event.  VM exit occurs in response to
certain instructions and events.

The behavior of processor execution in guest mode is controlled by a
virtual machine control structure (VMCS). VMCS contains the guest state
(loaded at VM Entry, and saved at VM Exit), the host state, (loaded at
the time of VM exit), and the guest execution controls. ACRN hypervisor
creates a VMCS data structure for each virtual CPU, and uses the VMCS to
configure the behavior of the processor running in guest mode.

When the execution of the guest hits a sensitive
instruction\ :sup:``[a] <#cmnt1>`__\ `[b] <#cmnt2>`__\ `[c] <#cmnt3>`__\ `[d] <#cmnt4>`__`\ (for
example:), a VM exit event may happen as defined in the VMCS
configuration. Control goes back to the ACRN hypervisor when the VM exit
happens. ACRN hypervisor emulates the guest instruction (if it is due to
privilege issue) and resumes the guest to its next instruction, or fix
the VM exit reason (for example if a guest memory page is not mapped
yet) and resume the guest to re-execute the instruction.

Note that the address space used in VMM mode is different from that in
guest mode. The guest mode and VMM mode use different memory mapping
tables, and therefore the ACRN hypervisor is protected from guest
access. The ACRN hypervisor uses EPT to map the guest address, using the
guest page table to map from guest linear address to guest physical
address, and using the EPT table to map from guest physical address to
machine physical address or host physical address (HPA).

.. _h.ow376uumyc8t:

2.3.4 ACRN Device Model 
~~~~~~~~~~~~~~~~~~~~~~~~

Let's explore how device emulation works today in other hypervisor
architectures where device emulation is done within the hypervisor, or
where device emulation is pushed to an external application outside the
hypervisor.

The first architecture is device emulation within the hypervisor which
is  a common method implemented within the VMware\* workstation product
(an operating system-based hypervisor). In this method, the hypervisor
includes emulations of common devices that the various guest operating
systems can share, including virtual disks, virtual network adapters,
and other necessary platform elements.

The second  architecture is called user space device emulation. As the
name implies, rather than the device emulation being embedded within the
hypervisor, it is instead implemented in a separate user space
application. QEMU provides this kind of device emulation and is used by
a large number of independent hypervisors. This model is advantageous,
because the device emulation is independent of the hypervisor and can
therefore be shared for other hypervisors. It also permits arbitrary
device emulation without having to burden the hypervisor (which operates
in a privileged state) with this functionality.

The third variation on hypervisor-based device emulation is
paravirtualized (PV) drivers. In this model introduced by the \ `XEN
project <https://www.google.com/url?q=https://wiki.xenproject.org/wiki/Understanding_the_Virtualization_Spectrum&sa=D&ust=1520533207671000&usg=AFQjCNFsQ8Qtl8lWxgKO_fDJsz1pcdYatA>`__\ ,
the hypervisor includes the physical drivers, and each guest operating
system includes a hypervisor-aware driver that works in concert with the
hypervisor drivers.

In the device emulation models discussed above, there's a price to pay
for sharing devices. Whether device emulation is performed in the
hypervisor, or in user space within an independent VM, overhead exists.
This overhead is worthwhile as long as the devices need to be shared by
multiple guest operating systems. If sharing is not necessary, then
there are more efficient methods for accessing devices, for example
“pass-through”.

ACRN device model is a placeholder of the UOS. It allocates memory for
the User OS, configures and initializes the devices used by the UOS,
loads the virtual firmware, initializes the virtual CPU state, and
invokes the ACRN hypervisor service to execute the guest instructions.
 ACRN Device model is an application running in the Service OS that
emulates devices based on command line configuration, the architecture
as below -:

|image4|

Figure 5 ACRN Device Model

(??? There’re two green boxed for vLAPIC???)

ACRN Device model involves below 3 aspects:

Device Emulation: ACRN Device model provides device emulation
routines, these routines register their I/O handlers to the I/O
dispatcher. When there is an I/O request from the User OS device, the
I/O dispatcher will dispatch this request to the corresponding device
emulation routine.

I/O Path:  see section 2.3.6

VHM: The Virtio and Hypervisor Service Module is a kernel module in the
Service OS acting as a middle layer to support the device model. The VHM
and its client handling flow is described below:

#. ACRN hypervisor IOREQ is forwarded to the VHM by an upcall
   notification to the SOS.
#. VHM will mark the IOREQ as “in process” so that the same IOREQ will
   not pick up again. The IOREQ will be sent to the client for handling.
   Meanwhile, the VHM is ready for another IOREQ.
#. IOREQ clients are either SOS Userland application or Service OS
   Kernel space module. Once IOREQ is processed and completed, the
   Client will issue an IOCTL call to the VHM to notify IOREQ state
   change. The VHM then checks and hypercalls to ACRN hypervisor
   notifying it that the IOREQ has completed.

Note:         Userland:  dm as ACRN Device Model. Kernel space:  VBS-K,
MPT Service, VHM itself

.. _h.cr02ry2l08p3:

2.3.5 Pass through
~~~~~~~~~~~~~~~~~~

At the highest level, device pass-through is about providing isolation
of a device to a given guest operating system so that the device can be
used exclusively by that guest.

|image5|

Figure 6 Device Passthrough

Near to native performance can be achieved by using device passthrough.
This is perfect for networking applications (or those that have high
disk I/O) that have not adopted virtualization because of contention and
performance degradation through the hypervisor (to a driver in the
hypervisor or through the hypervisor to a user space emulation). But
assigning devices to specific guests is also useful when those devices
inherently wouldn’t be shared. For example, if a system includes
multiple video adapters, those adapters could be passed through to
unique guest domains.

Finally, there may be specialized PCI devices that only one guest domain
uses, so they should be passed through to the guest. Individual USB
ports could be isolated to a given domain too, or a serial port (which
is itself not shareable) could be isolated to a particular guest.this is
for general case, in ACRN hypervisor, we support USB controller Pass
through only and we don’t support pass through for a legacy serial
port, for example 0x3f8.  

.. _h.rm7rcgdx4vep:

2.3.5.1 Hardware support for device passthrough
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Intel’s current processor architectures provides support for device
pass-through with VT-d, VT-d maps guest physical address to machine
physical address, so device can use guest physical address directly.
When this mapping occurs, the hardware takes care of access (and
protection), and the guest operating system can use the device as if it
was  a non-virtualized system. In addition to mapping guest to physical
memory, isolation is provided that this device can not access memory
belongs to other guests or hypervisor.

Another innovation that helps interrupts scale to large numbers of VMs
is called Message Signaled Interrupts (MSI). Rather than relying on
physical interrupt pins to be associated with a guest, MSI transforms
interrupts into messages that are more easily virtualized (scaling to
thousands of individual interrupts). MSI has been available since PCI
version 2.2 but is also available in PCI Express (PCIe), where it allows
fabrics to scale to many devices. MSI is ideal for I/O virtualization,
as it allows isolation of interrupt sources (as opposed to physical pins
that must be multiplexed or routed through software).

.. _h.x2z9ky9whfl4:

2.3.5.2 hypervisor support for device passthrough
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

By using the latest virtualization-enhanced processor architectures, a
number of hypervisors and virtualization solutions can support device
pass-through (using VT-d), including Xen and KVM, as well as this open
source ACRN hypervisor. In most cases, the guest operating system (User
OS) must be compiled to support pass-through, which is available as a
kernel build-time option. Hiding the devices from the host VM may also
be required (as is done with Xen using pciback). Some restrictions apply
in PCI, for example, PCI devices behind a PCIe-to-PCI bridge must be
assigned to the same guest OS. PCIe does not have this restriction.

.. _h.7brtlt85ttvh:

2.3.6 ACRN I/O mediator  
~~~~~~~~~~~~~~~~~~~~~~~~~

Figure 7 shows the flow of an example I/O emulation path. When a guest
execute an I/O instruction (PIO or MMIO), a VM exit happens. ACRN
hypervisor takes the control, and apply further process base on the VM
exit reason, which is a VMX_EXIT_REASON_IO_INSTRUCTION for PIO access.
ACRN hypervisor will then fetch and decide the guest instruction, and
realized it is an PIO instruction (in AL, 20h in this example), and put
the decoded information (including the PIO address, size of access,
read/write, and target register) into the shared page, and
notify/interrupt SOS to process.
The virtio and hypervisor service module (VHM) in SOS received the
interrupt, and query the IO request ring to get the PIO instruction
details. It will check to see if any in kernel device claimed the
ownership of the IO port: if a kernel module claimed it, the kernel
module is activated to execute its processing APIs, otherwise, VHM
module will leave the IO request in the shared page and wake up the
device model thread to process.
ACRN device model follow same mechanism of the VHM does. The I/O
processing thread of device model queries the IO request ring to get the
PIO instruction details and check to see if any (guest) device emulation
modules claimed the ownership of the IO port: if a module claimed it,
the module is invoked to execute its processing APIs.
After the ACRN device module completes the emulation (port IO 20h access
in this example), say uDev1 here. The uDev1 will put the result into the
shared page. That is the register AL in this example. ACRN device model
will then return the control to ACRN hypervisor to indicate the
completion of an IO instruction emulation, typically thru VHM/hypercall.
The ACRN hypervisor then knows the completion of IO emulation, and copy
the result to the guest register context, advance the guest IP to
indicate the completion of instruction execution, and resume the guest.
MMIO path is very similar, except the VM exit reason is different. MMIO
access usually is trapped thru VMX_EXIT_REASON_EPT_VIOLATION in
hypervisor. The rest are same.
\ |image6|

Figure 7 I/O Emulation Path

.. _h.dxis9thdolvb:

2.3.7 VirtIO framework architecture    
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Virtio is an abstraction for a set of common emulated devices in any
type of hypervisor. In this open source reference stack, our
implementation is compatible with Virtio spec 0.9 and 1.0. The purpose
of virtio and the specification is that virtual environments and guests
should have a straightforward, efficient, standard and extensible
mechanism for virtual devices, rather than boutique per-environment or
per-OS mechanisms.

Virtio provides a common frontend driver framework which not only
standardizes device interfaces, but also increases code reuse across
different virtualization platforms.

 

|image7|

Figure 8 Virtio Architecture

To better understand the Virtio, especially its usage in this open
source ACRN project, several key concepts of Virtio are highlighted
here:

Front-End virtio driver (a.k.a. frontend driver, or FE driver in this
document)

Virtio adopts a frontend-backend architecture, which enables a simple
but flexible framework for both frontend and backend virtio driver. The
FE driver provides a configure interface, pass messages, produce
requests, and notify backend virtio driver. As a result, the FE driver
is easy to implement and the performance overhead of emulating device is
eliminated.

Back-End virtio driver (a.k.a. backend driver, or BE driver in this
document)

Similar to FE driver, the BE driver, runs either in user-land or
kernel-land of host OS. The BE driver consumes requests from FE driver
and send them to the host’s native device driver. Once the requests are
done by the host native device driver, the BE driver notifies the FE
driver about the completeness of the requests.

Straightforward: virtio devices as standard devices on existing Buses

Instead of creating new device buses from scratch, virtio devices are
built on existing buses. This gives a straightforward way for both FE
and BE drivers to interact with each other. For example, FE driver could
read/write registers of the device, and the virtual device could
interrupt FE driver, on behalf of the BE driver, in case of something is
happening.
Currently virtio supports PCI/PCIe bus and MMIO bus. In this open source
project, only PCI/PCIe bus is supported, and all the virtio devices
share the same vendor ID 0x1AF4.

Efficient: batching operation is encouraged

Batching operation and deferred notification are important to achieve
high-performance I/O, since notification between FE and BE driver
usually involves an expensive exit of the guest. Therefore batching
operating and notification suppression are highly encouraged if
possible. This will give an efficient implementation for the performance
critical devices.

Standard: virtqueue

All the virtio devices share a standard ring buffer and descriptor
mechanism, which is called a virtqueue, shown in Figure 6. A virtqueue
is a queue of scatter-gather buffers and there are three important
methods on virtqueues: add_buf is for adding a request/response buffer
in a virtqueue, get_buf is for getting a response/request in a
virtqueue, and kick is for notifying the other side for a virtqueue to
consume buffers.
The virtqueues are created in guest physical memory by the FE drivers,
and the BE drivers only need to parse the virtqueue structures to obtain
the requests and get the requests done. How virtqueue is organized is
specific to User OS. In the implementation of virtio in Linux, the
virtqueue is implemented as a ring buffer structure called vring.

In this open source project, the virtqueue APIs can be leveraged
directly so that users don’t need to worry about the details of the
virtqueue. In the meantime, developers could also refer to User OS for
more details about the virtqueue implementations.

 Extensible: feature bits

A simple extensible feature negotiation mechanism for each virtual
device and its driver, so that each virtual device could claim its
device specific features while the corresponding driver could respond to
the device with the subset of features the driver understands. The
feature mechanism enables forward and backward compatibility for the
virtual device and driver.

In this open source reference stack, also we implemented 2 parts: user
land and kernel space:  

|image8|

Figure 9 - Virtio Framework – User Land

In user land of Virtio framework, the implement is compatible with
Virtio Spec 0.9/1.0, and the VBS-U static link with DM, and communicate
with Device Model through PCIe I/F:

PIO/MMIO or MSI/MSIx. VBS-U access virtio APIs through user space vring
service API helpers, User space vring service API helpers access shared
ring through remote memory map (mmap), VHM maps UOS memory with help of
ACRN Hypervisor.

|image9|

Figure 10 - Virtio Framework – Kernel Space

VBS-U offloads data plane processing to VBS-K, VBS-U initializes VBS-K
at the right timings, for example. FE driver sets
VIRTIO_CONFIG_S_DRIVER_OK, in order to avoid unnecessary device
configuration changes in running time, it allow VBS-K to access shared
rings through VBS-K virtqueue APIs and VBS-K virtqueue APIs are similar
to VBS-U virtqueue APIs.  VBS-K registers as VHM client(s) to handle a
continuous range of registers

, One or multiple VHM-client for each VBS-K and could be single
VHM-client for all VBS-Ks as well. VBS-K notifies FE throughVHM
interrupt APIs.

.. raw:: html

   <div class="c34">

`[a] <#cmnt_ref1>`__\ examples?

.. raw:: html

   </div>

.. raw:: html

   <div class="c34">

`[b] <#cmnt_ref2>`__\ good suggestion, need engineer team to input

.. raw:: html

   </div>

.. raw:: html

   <div class="c34">

`[c] <#cmnt_ref3>`__\ +jack.ren@intel.com  who can help to give an
example?

.. raw:: html

   </div>

.. raw:: html

   <div class="c34">

`[d] <#cmnt_ref4>`__\ Dong, Eddie

.. raw:: html

   </div>

.. |image0| image:: images/image3.png
.. |image1| image:: images/image7.png
.. |image2| image:: images/image9.png
.. |image3| image:: images/image8.png
.. |image4| image:: images/image10.png
.. |image5| image:: images/image5.png
.. |image6| image:: images/image1.png
.. |image7| image:: images/image2.png
.. |image8| image:: images/image6.png
.. |image9| image:: images/image4.png

